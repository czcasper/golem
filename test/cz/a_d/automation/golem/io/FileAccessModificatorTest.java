/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package cz.a_d.automation.golem.io;

import java.util.Arrays;
import java.util.List;
import org.junit.BeforeClass;
import org.junit.Test;
import static org.junit.Assert.*;
import org.junit.Rule;
import org.junit.rules.ExpectedException;

/**
 * Test for validation architectonic specification of functionality Enum class
 * for storing access rights used by golem URL interface.
 *
 * @author casper
 */
public class FileAccessModificatorTest {

    /**
     * Enum types used inside this test for validation of functionality.
     */
    protected static FileAccessModificator[] testTypes = {FileAccessModificator.READ, FileAccessModificator.WRITE, FileAccessModificator.EXECUTE, FileAccessModificator.CREATE};
    /**
     * Short name representation of enum stored into array in same order like
     * testTypes array. Order is part of testing and both arrays are checked if
     * lenghts is matching to number of defined values inside enum.
     */
    protected static char[] testTypesShortNames = {'r', 'w', 'x', 'c'};

    /**
     * JUnit variable for testing exception generated by tests.
     */
    @Rule
    public ExpectedException testException = ExpectedException.none();

    /**
     * Validate test configuration if it is matching to definition of enum.
     */
    @BeforeClass
    public static void setUpClass() {
        assertEquals("Invalid test data definition.", testTypes.length, testTypesShortNames.length);
        assertEquals("Test data doesn't corresponds to enum definition", testTypes.length, FileAccessModificator.values().length);
    }

    /**
     * Test validate all possible values which shlould be defined by this enum
     * class.
     */
    @Test
    public void testValues() {
        FileAccessModificator[] result = FileAccessModificator.values();
        assertNotNull(result);
        List<FileAccessModificator> list = Arrays.asList(result);
        for (int i = 0; i < testTypes.length; i++) {
            assertTrue(list.contains(testTypes[i]));
            assertEquals(testTypesShortNames[i], list.get(list.indexOf(testTypes[i])).value);
        }
    }

    /**
     * Test where is validated conversion enum to string and back by using
     * combination of name method and value method defined in enum.
     */
    @Test
    public void testValueOf() {
        for (FileAccessModificator testType : testTypes) {
            FileAccessModificator result = FileAccessModificator.valueOf(testType.name());
            assertSame(testType, result);
        }
    }

    /**
     * Test validate functionality of method valueOf for invalid string
     * definition.
     */
    @Test
    public void testValueOfException() {
        testException.expect(IllegalArgumentException.class);
        testException.expectMessage("");
        FileAccessModificator.valueOf("");
    }

    /**
     * Test if method is protected against to null and invalid input and
     * generation of all expected rights in expected order defined by test data.
     */
    @Test
    public void testFromCharStream() {
        CharSequence modificators = null;
        FileAccessModificator[] result = FileAccessModificator.fromCharStream(modificators);
        assertNull(result);

        modificators = "";
        result = FileAccessModificator.fromCharStream(modificators);
        assertNull(result);

        for (Character c : testTypesShortNames) {
            modificators += Character.toString(c);
        }
        result = FileAccessModificator.fromCharStream(modificators);
        assertArrayEquals(testTypes, result);
    }

    /**
     * Test if method extract access rights information from format defined by
     * query and protection of method against not valid input including null.
     */
    @Test
    public void testFromQuery() {
        String query = null;
        FileAccessModificator[] result = FileAccessModificator.fromQuery(query);
        assertNull(result);

        query = "";
        result = FileAccessModificator.fromQuery(query);
        assertNull(result);

        query = "access={";
        boolean first = true;
        for (FileAccessModificator mod : testTypes) {
            if (first) {
                first = false;
            } else {
                query += ",";
            }
            query += mod.name().toLowerCase();
        }
        query += "}";

        result = FileAccessModificator.fromQuery(query);
        assertArrayEquals(testTypes, result);

        query = "aldhfkaccess=fkldajsh;" + query + "&{read,write}asdasdjhsdk";
        result = FileAccessModificator.fromQuery(query);
        assertArrayEquals(testTypes, result);
    }

    /**
     * Test if method toString return expected short repesentation of rights.
     */
    @Test
    public void testToString() {
        for (int i = 0; i < testTypes.length; i++) {
            assertEquals(Character.toString(testTypesShortNames[i]), testTypes[i].toString());
        }
    }

    /**
     * Test if method is protected against null and incorect parameter values
     * also test if short names defined for test are correctly transleted to
     * expected instance of enum.
     */
    @Test
    public void testFromChar() {
        Character ch = null;
        FileAccessModificator result = FileAccessModificator.fromChar(ch);
        assertNull(result);
        ch =' ';
        result = FileAccessModificator.fromChar(ch);
        assertNull(result);
        
        for (int i = 0; i < testTypes.length; i++) {
            assertSame(testTypes[i], FileAccessModificator.fromChar(testTypesShortNames[i]));
        }
    }

}
